datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            Int       @id @default(autoincrement())
  username      String    @unique
  email         String    @unique
  passwordHash  String
  name          String?
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())

  // Queue & game state
  queueStatus   String?   @default("offline")
  queuedAt      DateTime?
  queuedDraftId Int?

  // Relations
  drafts         Draft[]
  queuedDraft    Draft?    @relation("UserQueuedDraft", fields: [queuedDraftId], references: [id], onDelete: SetNull)
  
  // Changed from one-to-one to one-to-many (User can have multiple active games)
  currentGames   Game[]    @relation("UserCurrentGames")
  
  gamesAsPlayer1 Game[]    @relation("Player1")
  gamesAsPlayer2 Game[]    @relation("Player2")

  accounts       Account[]
  sessions       Session[]

  @@index([queueStatus])
  @@index([queuedDraftId])
}

model Game {
  id        Int       @id @default(autoincrement())
  player1Id Int
  player2Id Int
  status    String    @default("waiting")
  draft1Id  Int?
  draft2Id  Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  // Add field to track which user has this as current game (optional)
  currentForUserId Int?

  // Relations
  player1      User      @relation("Player1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2      User      @relation("Player2", fields: [player2Id], references: [id], onDelete: Cascade)

  draft1       Draft?    @relation("GameDraft1", fields: [draft1Id], references: [id], onDelete: SetNull)
  draft2       Draft?    @relation("GameDraft2", fields: [draft2Id], references: [id], onDelete: SetNull)

  // One-to-many back-relation
  currentForUser User?   @relation("UserCurrentGames", fields: [currentForUserId], references: [id], onDelete: SetNull)

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
  @@index([createdAt])
  @@index([draft1Id])
  @@index([draft2Id])
  @@index([currentForUserId])
}

model Draft {
  id          Int       @id @default(autoincrement())
  userId      Int
  name        String?
  fen         String
  points      Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  queuedByUsers  User[]    @relation("UserQueuedDraft")
  
  // Back-relations from Game
  gamesAsDraft1  Game[]    @relation("GameDraft1")
  gamesAsDraft2  Game[]    @relation("GameDraft2")

  @@index([userId])
  @@index([updatedAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
