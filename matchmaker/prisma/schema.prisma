datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            Int       @id @default(autoincrement())
  username      String    @unique
  email         String    @unique
  passwordHash  String
  name          String?
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  
  // ELO rating system
  elo           Int       @default(1200)
  gamesPlayed   Int       @default(0)
  wins          Int       @default(0)
  losses        Int       @default(0)
  draws         Int       @default(0)
  
  // Queue & game state
  queueStatus   String?   @default("offline")
  queuedAt      DateTime?
  queuedDraftId Int?
  
  // Relations
  drafts         Draft[]
  queuedDraft    Draft?    @relation("UserQueuedDraft", fields: [queuedDraftId], references: [id], onDelete: SetNull)
  currentGames   Game[]    @relation("UserCurrentGames")
  gamesAsPlayer1 Game[]    @relation("Player1")
  gamesAsPlayer2 Game[]    @relation("Player2")
  gamesAsWhite   Game[]    @relation("WhitePlayer")
  accounts       Account[]
  sessions       Session[]
  
  @@index([queueStatus])
  @@index([queuedDraftId])
  @@index([elo])
}

model Game {
  id               Int       @id @default(autoincrement())
  player1Id        Int
  player2Id        Int
  // whitePlayerId: the user who plays white. Always set at game creation.
  // draft1 = white's draft, draft2 = black's draft.
  whitePlayerId    Int
  status           String    @default("waiting")
  draft1Id         Int?
  draft2Id         Int?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  fen              String?
  prepStartedAt    DateTime?
  readyPlayer1     Boolean   @default(false)
  readyPlayer2     Boolean   @default(false)
  auxPointsPlayer1 Int       @default(6)
  auxPointsPlayer2 Int       @default(6)
  currentForUserId Int?
  
  // Time control system
  lastMoveAt       DateTime?
  lastMoveBy       Int?
  moveNumber       Int        @default(0)
  
  // Per-player timebanks (in milliseconds)
  player1Timebank  Int        @default(60000)
  player2Timebank  Int        @default(60000)
  
  // Game result and ELO tracking
  winnerId         Int?
  player1EloBefore Int?
  player2EloBefore Int?
  player1EloAfter  Int?
  player2EloAfter  Int?
  eloChange        Int?
  endReason        String?
  
  // Relations
  player1        User      @relation("Player1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2        User      @relation("Player2", fields: [player2Id], references: [id], onDelete: Cascade)
  whitePlayer    User      @relation("WhitePlayer", fields: [whitePlayerId], references: [id], onDelete: Cascade)
  draft1         Draft?    @relation("GameDraft1", fields: [draft1Id], references: [id], onDelete: SetNull)
  draft2         Draft?    @relation("GameDraft2", fields: [draft2Id], references: [id], onDelete: SetNull)
  currentForUser User?     @relation("UserCurrentGames", fields: [currentForUserId], references: [id], onDelete: SetNull)
  
  @@index([player1Id])
  @@index([player2Id])
  @@index([whitePlayerId])
  @@index([status])
  @@index([createdAt])
  @@index([draft1Id])
  @@index([draft2Id])
  @@index([currentForUserId])
  @@index([winnerId])
  @@index([lastMoveAt])
}

model Draft {
  id          Int       @id @default(autoincrement())
  userId      Int
  name        String?
  fen         String
  points      Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  queuedByUsers  User[]    @relation("UserQueuedDraft")
  gamesAsDraft1  Game[]    @relation("GameDraft1")
  gamesAsDraft2  Game[]    @relation("GameDraft2")
  
  @@index([userId])
  @@index([updatedAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  
  @@unique([identifier, token])
}
